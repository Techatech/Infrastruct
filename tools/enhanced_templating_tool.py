import yaml
import json
import re
from typing import Dict, List, Any
from datetime import datetime

class EnhancedTemplatingTool:
    def __init__(self):
        self.default_envid = "dev"  # Can be overridden
        
    def generate_tags(self, resource_type: str, instance_number: int = 1, envid: str = None) -> List[Dict]:
        """Generate standardized tags for CloudFormation resources"""
        if envid is None:
            envid = self.default_envid
            
        # Normalize resource type for naming
        resource_type_normalized = self.normalize_resource_type(resource_type)
        
        tags = [
            {
                "Key": "Name",
                "Value": f"{envid}-{resource_type_normalized}{instance_number:02d}"
            },
            {
                "Key": "Environment", 
                "Value": envid
            },
            {
                "Key": "CreatedBy",
                "Value": "Infrastruct"
            },
            {
                "Key": "CreatedDate",
                "Value": datetime.now().strftime("%Y-%m-%d")
            },
            {
                "Key": "ManagedBy",
                "Value": "CloudFormation"
            }
        ]
        
        return tags
    
    def normalize_resource_type(self, resource_type: str) -> str:
        """Normalize resource type for consistent naming"""
        type_mapping = {
            'AWS::EC2::Instance': 'Server',
            'AWS::RDS::DBInstance': 'Database',
            'AWS::S3::Bucket': 'Bucket',
            'AWS::ElasticLoadBalancingV2::LoadBalancer': 'LoadBalancer',
            'AWS::Lambda::Function': 'Function',
            'AWS::DynamoDB::Table': 'Table',
            'AWS::CloudFront::Distribution': 'CDN',
            'AWS::Route53::RecordSet': 'DNS',
            'AWS::VPC::VPC': 'VPC',
            'AWS::EC2::SecurityGroup': 'SecurityGroup',
            'AWS::IAM::Role': 'Role',
            'AWS::ECS::Service': 'Service',
            'AWS::ECS::Cluster': 'Cluster'
        }
        
        return type_mapping.get(resource_type, resource_type.split('::')[-1])
    
    def create_enhanced_template(self, plan_text: str, envid: str = None) -> str:
        """Create CloudFormation template with enhanced tagging from architecture plan"""
        if envid is None:
            envid = self.default_envid
            
        # Parse the plan to identify resources
        resources = self.parse_plan_for_resources(plan_text)
        
        # Create CloudFormation template structure
        template = {
            "AWSTemplateFormatVersion": "2010-09-09",
            "Description": f"Infrastructure as Code template generated by Infrastruct for {envid} environment",
            "Parameters": {
                "EnvironmentId": {
                    "Type": "String",
                    "Default": envid,
                    "Description": "Environment identifier for resource naming and tagging"
                }
            },
            "Resources": {},
            "Outputs": {}
        }
        
        # Add resources with proper tagging
        resource_counters = {}
        
        for resource_info in resources:
            resource_type = resource_info['type']
            resource_name = resource_info['name']
            
            # Count instances of each resource type
            if resource_type not in resource_counters:
                resource_counters[resource_type] = 0
            resource_counters[resource_type] += 1
            
            # Generate resource definition
            resource_def = self.create_resource_definition(
                resource_type, 
                resource_info, 
                resource_counters[resource_type],
                envid
            )
            
            template["Resources"][resource_name] = resource_def
            
            # Add outputs for important resources
            if resource_type in ['AWS::EC2::Instance', 'AWS::ElasticLoadBalancingV2::LoadBalancer', 'AWS::S3::Bucket']:
                template["Outputs"][f"{resource_name}Id"] = {
                    "Description": f"ID of {resource_name}",
                    "Value": {"Ref": resource_name},
                    "Export": {
                        "Name": {"Fn::Sub": f"${{{envid}}}-{resource_name}-Id"}
                    }
                }
        
        # Convert to YAML
        yaml_template = yaml.dump(template, default_flow_style=False, sort_keys=False)
        
        # Add header comment
        header = f"""# AWS CloudFormation Template
# Generated by Infrastruct on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
# Environment: {envid}
# 
# This template follows Infrastruct tagging conventions:
# - Name: {{envid}}-ResourceType-InstanceNumber
# - Environment: {{envid}}
# - CreatedBy: Infrastruct
#
# Deploy with: aws cloudformation create-stack --stack-name {envid}-infrastructure --template-body file://template.yaml

"""
        
        return header + yaml_template
    
    def parse_plan_for_resources(self, plan_text: str) -> List[Dict]:
        """Parse architecture plan to identify AWS resources"""
        resources = []
        plan_lower = plan_text.lower()
        
        # Resource patterns and their CloudFormation types
        resource_patterns = {
            r'ec2|server|compute instance': 'AWS::EC2::Instance',
            r'rds|database|db instance': 'AWS::RDS::DBInstance',
            r's3|bucket|storage': 'AWS::S3::Bucket',
            r'load balancer|elb|alb': 'AWS::ElasticLoadBalancingV2::LoadBalancer',
            r'lambda|function': 'AWS::Lambda::Function',
            r'dynamodb|nosql': 'AWS::DynamoDB::Table',
            r'cloudfront|cdn': 'AWS::CloudFront::Distribution',
            r'route53|dns': 'AWS::Route53::RecordSet',
            r'vpc|virtual private cloud': 'AWS::EC2::VPC',
            r'security group': 'AWS::EC2::SecurityGroup',
            r'iam role|role': 'AWS::IAM::Role',
            r'ecs service': 'AWS::ECS::Service',
            r'ecs cluster': 'AWS::ECS::Cluster'
        }
        
        resource_counter = {}
        
        for pattern, cf_type in resource_patterns.items():
            matches = re.findall(pattern, plan_lower)
            if matches:
                count = len(matches)
                if cf_type not in resource_counter:
                    resource_counter[cf_type] = 0
                
                for i in range(count):
                    resource_counter[cf_type] += 1
                    resource_name = f"{cf_type.split('::')[-1]}{resource_counter[cf_type]:02d}"
                    
                    resources.append({
                        'name': resource_name,
                        'type': cf_type,
                        'instance': resource_counter[cf_type]
                    })
        
        # If no specific resources found, add basic web architecture
        if not resources:
            resources = [
                {'name': 'WebServer01', 'type': 'AWS::EC2::Instance', 'instance': 1},
                {'name': 'Database01', 'type': 'AWS::RDS::DBInstance', 'instance': 1},
                {'name': 'Bucket01', 'type': 'AWS::S3::Bucket', 'instance': 1}
            ]
        
        return resources
    
    def create_resource_definition(self, resource_type: str, resource_info: Dict, instance_num: int, envid: str) -> Dict:
        """Create CloudFormation resource definition with proper tagging"""
        tags = self.generate_tags(resource_type, instance_num, envid)
        
        # Base resource definitions
        resource_definitions = {
            'AWS::EC2::Instance': {
                "Type": "AWS::EC2::Instance",
                "Properties": {
                    "ImageId": "ami-0abcdef1234567890",  # Amazon Linux 2
                    "InstanceType": "t3.micro",
                    "SecurityGroupIds": [{"Ref": "WebSecurityGroup"}],
                    "Tags": tags,
                    "UserData": {
                        "Fn::Base64": {
                            "Fn::Sub": "#!/bin/bash\nyum update -y\nyum install -y httpd\nsystemctl start httpd\nsystemctl enable httpd\necho '<h1>Hello from ${EnvironmentId}</h1>' > /var/www/html/index.html"
                        }
                    }
                }
            },
            'AWS::RDS::DBInstance': {
                "Type": "AWS::RDS::DBInstance",
                "Properties": {
                    "DBInstanceClass": "db.t3.micro",
                    "Engine": "mysql",
                    "MasterUsername": "admin",
                    "MasterUserPassword": "ChangeMe123!",
                    "AllocatedStorage": "20",
                    "DBName": {"Fn::Sub": "${EnvironmentId}database"},
                    "Tags": tags
                }
            },
            'AWS::S3::Bucket': {
                "Type": "AWS::S3::Bucket",
                "Properties": {
                    "BucketName": {"Fn::Sub": "${EnvironmentId}-${AWS::AccountId}-${AWS::Region}-bucket"},
                    "Tags": tags,
                    "PublicAccessBlockConfiguration": {
                        "BlockPublicAcls": True,
                        "BlockPublicPolicy": True,
                        "IgnorePublicAcls": True,
                        "RestrictPublicBuckets": True
                    }
                }
            },
            'AWS::ElasticLoadBalancingV2::LoadBalancer': {
                "Type": "AWS::ElasticLoadBalancingV2::LoadBalancer",
                "Properties": {
                    "Name": {"Fn::Sub": "${EnvironmentId}-loadbalancer"},
                    "Scheme": "internet-facing",
                    "Type": "application",
                    "Tags": tags
                }
            },
            'AWS::Lambda::Function': {
                "Type": "AWS::Lambda::Function",
                "Properties": {
                    "FunctionName": {"Fn::Sub": "${EnvironmentId}-function"},
                    "Runtime": "python3.9",
                    "Handler": "index.handler",
                    "Code": {
                        "ZipFile": "def handler(event, context):\n    return {'statusCode': 200, 'body': 'Hello from Lambda!'}"
                    },
                    "Role": {"Fn::GetAtt": ["LambdaExecutionRole", "Arn"]},
                    "Tags": tags
                }
            },
            'AWS::DynamoDB::Table': {
                "Type": "AWS::DynamoDB::Table",
                "Properties": {
                    "TableName": {"Fn::Sub": "${EnvironmentId}-table"},
                    "BillingMode": "PAY_PER_REQUEST",
                    "AttributeDefinitions": [
                        {"AttributeName": "id", "AttributeType": "S"}
                    ],
                    "KeySchema": [
                        {"AttributeName": "id", "KeyType": "HASH"}
                    ],
                    "Tags": tags
                }
            }
        }
        
        # Add security group for EC2 instances
        if resource_type == 'AWS::EC2::Instance':
            # This would be added to the template resources separately
            pass
        
        return resource_definitions.get(resource_type, {
            "Type": resource_type,
            "Properties": {
                "Tags": tags
            }
        })
    
    def add_security_group(self, template: Dict, envid: str) -> Dict:
        """Add a basic security group to the template"""
        tags = self.generate_tags("AWS::EC2::SecurityGroup", 1, envid)
        
        template["Resources"]["WebSecurityGroup"] = {
            "Type": "AWS::EC2::SecurityGroup",
            "Properties": {
                "GroupDescription": "Security group for web servers",
                "SecurityGroupIngress": [
                    {
                        "IpProtocol": "tcp",
                        "FromPort": 80,
                        "ToPort": 80,
                        "CidrIp": "0.0.0.0/0"
                    },
                    {
                        "IpProtocol": "tcp", 
                        "FromPort": 443,
                        "ToPort": 443,
                        "CidrIp": "0.0.0.0/0"
                    }
                ],
                "Tags": tags
            }
        }
        
        return template